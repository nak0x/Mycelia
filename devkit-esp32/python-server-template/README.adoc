= Unified HTTP + WebSocket Framework (Frame-based)
:toc:
:toclevels: 3
:sectnums:

A lightweight Python framework to build an HTTP + WebSocket server where *everything* (HTTP payloads and WS messages) uses the same JSON *Frame* format.

It is designed to feel like a mini-framework:

* routes are declared in `config.json`
* developers implement controller classes (delegates)
* the framework handles:
** HTTP server
** WebSocket server
** WS client registry + broadcast
** Frame validation on input/output

== Requirements

* Python 3.10+
* macOS / Windows supported
* venv is required

== Setup (venv)

=== macOS / Linux

[source,bash]
----
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
----

=== Windows (PowerShell)

[source,powershell]
----
py -m venv .venv
.venv\Scripts\Activate.ps1
pip install -r requirements.txt
----

== Run

[source,bash]
----
python main.py
----

The server reads `config.json`.

== Configuration (`config.json`)

`config.json` contains:

* server settings
* ws path
* HTTP routes

Each route points to a controller + method.

[source,json]
----
{
  "server": { "host": "0.0.0.0", "port": 8000, "ws_path": "/ws" },
  "routes": [
    { "method": "GET", "path": "/health", "controller": "app.controllers.core.CoreController", "action": "health" },
    { "method": "POST", "path": "/api/broadcast", "controller": "app.controllers.core.CoreController", "action": "broadcast" },
    { "method": "POST", "path": "/api/led", "controller": "app.controllers.sample.SampleController", "action": "led" }
  ]
}
----

== Frame format (mandatory)

All data **received via HTTP** and **sent/received via WebSocket** must follow this schema:

[source,json]
----
{
  "metadata": {
    "senderId": "CLIENT-123",
    "timestamp": 1730000000.0,
    "messageId": "MSG-2025-01-01T10:00:00-0001",
    "type": "ws-data",
    "receiverId": "SERVER-XYZ",
    "status": { "connection": 200 }
  },
  "payload": [
    { "datatype": "boolean", "value": true, "slug": "led" }
  ]
}
----

If a frame is invalid, the framework returns/sends an error frame with status codes.

== WebSocket

Connect to:

[source,text]
----
ws://localhost:8000/ws
----

Behavior:

* any incoming WS frame is validated
* valid frames are automatically broadcast to all other clients (rebroadcast)
* invalid frames can be rejected with an error response (optional)

== HTTP

All POST endpoints expecting data expect a Frame.

Example: broadcast from HTTP to WS clients:

[source,bash]
----
curl -X POST http://localhost:8000/api/broadcast \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": {
      "senderId": "HTTP-CLIENT",
      "timestamp": 1730000000.0,
      "messageId": "MSG-HTTP-0001",
      "type": "http-data",
      "receiverId": "SERVER",
      "status": { "connection": 200 }
    },
    "payload": [
      { "datatype": "string", "value": "Hello WS clients!", "slug": "message" }
    ]
  }'
----

== Writing a controller

Create a controller class in `app/controllers/`.

Example:

[source,python]
----
from aiohttp import web
from app.controllers.base import BaseController
from app.frames.parser import parse_frame_from_request
from app.frames.factory import error_frame, ok_frame

class MyController(BaseController):

    async def do_something(self, request: web.Request) -> web.Response:
        frame = await parse_frame_from_request(request)

        # business logic...
        await self.hub.broadcast(frame.raw_json)

        return web.json_response(ok_frame(sender="SERVER", receiver=frame.receiver_id))
----

Then register the route in `config.json`:

[source,json]
----
{ "method":"POST", "path":"/api/do-something", "controller":"app.controllers.my.MyController", "action":"do_something" }
----

No extra wiring required.

== Summary

* `config.json` declares routes
* controllers contain your app logic
* Frame format is enforced for HTTP + WS
* broadcasting is built-in