= Unified HTTP + WebSocket Framework (Frame-based)
:toc:
:toclevels: 3
:sectnums:

A lightweight Python framework to build an HTTP + WebSocket server where *everything* (HTTP payloads and WS messages) uses the same JSON *Frame* format.

It is designed to feel like a mini-framework:

* routes are declared in `config.json`
* developers implement controller classes (delegates)
* the framework handles:
** HTTP server
** WebSocket server
** WS client registry + broadcast
** Frame validation on input/output
** WS payload dispatch by `slug` when the message targets the server

== Requirements

* Python 3.10+
* macOS / Windows supported
* venv is required

== Setup (venv)

=== macOS / Linux

[source,bash]
----
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
----

=== Windows (PowerShell)

[source,powershell]
----
py -m venv .venv
.venv\Scripts\Activate.ps1
pip install -r requirements.txt
----

== Run

[source,bash]
----
python main.py
----

The server reads `config.json`.

== Configuration (`config.json`)

`config.json` contains:

* server settings (including a unique `id`)
* ws path
* HTTP routes (controller + action)
* WS payload routes (slug -> controller + action)

=== Example

[source,json]
----
{
  "server": {
    "id": "SERVER-000000",
    "host": "0.0.0.0",
    "port": 8000,
    "ws_path": "/ws"
  },
  "routes": [
    { "method": "GET", "path": "/health", "controller": "app.controllers.core.CoreController", "action": "health" },
    { "method": "POST", "path": "/api/broadcast", "controller": "app.controllers.core.CoreController", "action": "broadcast" }
  ],
  "ws_payload_routes": {
    "ping": { "controller": "app.ws_controllers.core.CoreWsController", "action": "on_ping" }
  }
}
----

=== Server ID and senderId

The server `id` in config is used as the `metadata.senderId` for all frames *generated by the server* (ACK, ERROR, server events, etc.).

Incoming frames are not rewritten.

== Frame format (mandatory)

All data **received via HTTP** and **sent/received via WebSocket** must follow this schema:

[source,json]
----
{
  "metadata": {
    "senderId": "CLIENT-123",
    "timestamp": 1730000000.0,
    "messageId": "MSG-2025-01-01T10:00:00-0001",
    "type": "ws-data",
    "receiverId": "SERVER-000000",
    "status": { "connection": 200 }
  },
  "payload": [
    { "datatype": "string", "value": "ping", "slug": "ping" }
  ]
}
----

If a frame is invalid, the framework returns/sends an error frame with status codes.

== WebSocket

Connect to:

[source,text]
----
ws://localhost:8000/ws
----

=== Behavior

* any incoming WS frame is validated
* valid frames are automatically broadcast to all other clients (rebroadcast)
* invalid frames can be rejected with an error frame response
* if the incoming frame targets this server (`metadata.receiverId == server.id`):
** each payload item is dispatched by its `slug` to a WS controller defined in `ws_payload_routes`
** this is executed in addition to the normal rebroadcast

=== WS payload dispatch (slug-based)

When a WS frame targets this server, each payload item is processed individually:

* for each payload in `frame.payload`:
** read `payload.slug`
** lookup that slug in `config.json` -> `ws_payload_routes`
** call `controller.action(frame, payload, ws)`

If a slug has no route, it is ignored.

== HTTP

All POST endpoints expecting data expect a Frame.

Example: broadcast from HTTP to WS clients:

[source,bash]
----
curl -X POST http://localhost:8000/api/broadcast \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": {
      "senderId": "HTTP-CLIENT",
      "timestamp": 1730000000.0,
      "messageId": "MSG-HTTP-0001",
      "type": "http-data",
      "receiverId": "SERVER-000000",
      "status": { "connection": 200 }
    },
    "payload": [
      { "datatype": "string", "value": "Hello WS clients!", "slug": "message" }
    ]
  }'
----

== Writing an HTTP controller

Create a controller class in `app/http_controllers/`.

Example:

[source,python]
----
from aiohttp import web
from app.http_controllers.base import HttpController
from app.frames.parser import parse_frame_from_request

class MyController(HttpController):

    async def do_something(self, request: web.Request) -> web.Response:
        frame = await parse_frame_from_request(request)

        # business logic...
        await self.hub.broadcast(frame.raw_json)

        return web.json_response(self.build_frame(
            sender_id=frame.metadata.get("senderId", "UNKNOWN"),
            slug="ws_sent",
            datatype="string",
            value="do something"
        ))
----

Then register the route in `config.json`:

[source,json]
----
{ "method":"POST", "path":"/api/do-something", "controller":"app.http_controllers.my_controller.MyController", "action":"do_something" }
----

No extra wiring required.

== Writing a WS controller (payload slug handlers)

WS controllers are used only for WebSocket inbound messages targeting the server.

Create a WS controller class in `app/ws_controllers/`.

Handlers receive:

* `frame` (the full validated frame)
* `payload` (the payload dict for the specific slug)
* `ws` (the sender WebSocket connection)

Example:

[source,python]
----
from aiohttp import web
from app.ws_controllers.base import WsController
from app.frames.frame import Frame
import json, time
from datetime import datetime

class DeviceController(WsController):

    async def on_led(self, frame: Frame, payload: dict, ws: web.WebSocketResponse) -> None:
        value = bool(payload.get("value"))
        sender = frame.metadata.get("senderId", "UNKNOWN")

        # perform side-effects here...
        print("LED requested:", value)

        # optional: ACK only to sender
        await ws.send_str(json.dumps(self.build_frame(
            receiver_id=sender,
            slug="led",
            datatype="bool",
            value=True
        )))
----

Register it in `config.json`:

[source,json]
----
"ws_payload_routes": {
  "led": { "controller": "app.ws_controllers.device.DeviceController", "action": "on_led" }
}
----

== Summary

* `config.json` declares HTTP routes + WS payload routes
* HTTP controllers contain your HTTP logic
* WS controllers handle inbound WS payloads targeting the server (slug-based)
* Frame format is enforced for HTTP + WS
* WebSocket rebroadcast is built-in