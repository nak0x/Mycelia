= Unified HTTP + WebSocket Framework (Frame-based)
:toc:
:toclevels: 3
:sectnums:

A lightweight Python framework to build an HTTP + WebSocket server where *everything* (HTTP payloads and WS messages) uses the same JSON *Frame* format.

It is designed to feel like a mini-framework:

* routes are declared in `config.json`
* developers implement controller classes (delegates)
* the framework handles:
** HTTP server
** WebSocket server
** WS client registry + broadcast
** Frame validation on input/output
** WS action dispatch based on `action` (semantic actions)

== Requirements

* Python 3.10+
* macOS / Windows supported
* venv is required

== Setup (venv)

=== macOS / Linux

[source,bash]
----
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
----

=== Windows (PowerShell)

[source,powershell]
----
py -m venv .venv
.venv\Scripts\Activate.ps1
pip install -r requirements.txt
----

== Run

[source,bash]
----
python main.py
----

The server reads `config.json`.

== Configuration (`config.json`)

`config.json` contains:

* server settings (including a unique `id`)
* ws path
* HTTP routes (controller + action)
* WS action routes (`action` -> controller + method)

=== Example

[source,json]
----
{
  "server": {
    "id": "SERVER-000000",
    "host": "0.0.0.0",
    "port": 8000,
    "ws_path": "/ws"
  },
  "routes": [
    { "method": "GET", "path": "/health", "controller": "app.controllers.core.CoreController", "action": "health" },
    { "method": "POST", "path": "/api/broadcast", "controller": "app.controllers.core.CoreController", "action": "broadcast" }
  ],
  "ws_actions": {
    "ping": { "controller": "app.ws_controllers.core.CoreController", "action": "on_ping" },
    "led":  { "controller": "app.ws_controllers.device.DeviceController", "action": "on_led" }
  }
}
----

=== Server ID and senderId

The server `id` in config is used as the `metadata.senderId` for all frames *generated by the server* (ACK, ERROR, server events, etc.).

Incoming frames are not rewritten.

== Frame format (mandatory)

All data **received via HTTP** and **sent/received via WebSocket** must follow this schema:

[source,json]
----
{
  "metadata": {
    "timestamp": 1678886400,
    "senderId": "ESP32-010101"
  },
  "action": "ping",
  "value": null
}
----

Notes:

* `metadata.timestamp` and `metadata.senderId` are mandatory
* `action` is mandatory and must be a non-empty string
* `value` is optional and can be `null`, a primitive, an object, or an array

If a frame is invalid, the framework can ignore it or reply with an error (depending on implementation).

== WebSocket

Connect to:

[source,text]
----
ws://localhost:8000/ws
----

=== Behavior

* any incoming WS frame is validated (new format)
* if the incoming `action` exists in `config.json` under `ws_actions`, the configured controller method is called
* if the `action` is not configured, nothing happens (message is ignored by the action router)
* WebSocket rebroadcast can remain enabled (default in the provided implementation)

=== WS action dispatch (semantic-action based)

When a WS frame is received:

* read `frame.action`
* lookup `frame.action` in `config.json` -> `ws_actions`
* if found:
** instantiate the controller (singleton per class)
** call the configured method: `controller.<method>(frame, ws)`
* if not found:
** no controller is called

Example mapping:

[source,json]
----
"ws_actions": {
  "ping": { "controller": "app.ws_controllers.core.CoreController", "action": "on_ping" }
}
----

Means:

* incoming message with `"action": "ping"`
* calls `app.ws_controllers.core.CoreController.on_ping(frame, ws)`

== HTTP

All POST endpoints expecting data expect the same Frame format.

Example: broadcast from HTTP to WS clients:

[source,bash]
----
curl -X POST http://localhost:8000/api/broadcast \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": { "timestamp": 1730000000.0, "senderId": "HTTP-CLIENT" },
    "action": "broadcast",
    "value": { "message": "Hello WS clients!" }
  }'
----

== Writing an HTTP controller

Create a controller class in `app/http_controllers/` (or the folder used by your project).

Example:

[source,python]
----
from aiohttp import web
from app.http_controllers.base import HttpController
from app.frames.parser import parse_frame_from_request

class MyController(HttpController):

    async def do_something(self, request: web.Request) -> web.Response:
        frame = await parse_frame_from_request(request)

        # business logic...
        await self.hub.broadcast(frame.raw_json)

        # example response (server-generated frame)
        return web.json_response({
            "metadata": {
                "timestamp": 1730000000.0,
                "senderId": self.server_id
            },
            "action": "ack",
            "value": "done"
        })
----

Then register the route in `config.json`:

[source,json]
----
{ "method":"POST", "path":"/api/do-something", "controller":"app.http_controllers.my_controller.MyController", "action":"do_something" }
----

No extra wiring required.

== Writing a WS controller (semantic action handlers)

WS controllers are used to handle WebSocket inbound messages based on `action`.

Create a WS controller class in `app/ws_controllers/`.

Handlers receive:

* `frame` (the full validated frame)
* `ws` (the sender WebSocket connection)

Example:

[source,python]
----
from aiohttp import web
from app.ws_controllers.base import WsController
from app.frames.frame import Frame
import json, time

class CoreController(WsController):

    async def on_ping(self, frame: Frame, ws: web.WebSocketResponse) -> None:
        # optional: reply only to sender
        await ws.send_str(json.dumps({
            "metadata": {
                "timestamp": time.time(),
                "senderId": self.server_id
            },
            "action": "pong",
            "value": { "from": self.server_id, "to": frame.sender_id }
        }))
----

Register it in `config.json`:

[source,json]
----
"ws_actions": {
  "ping": { "controller": "app.ws_controllers.core.CoreController", "action": "on_ping" }
}
----

== Summary

* `config.json` declares HTTP routes + WS action routes
* HTTP controllers contain your HTTP logic
* WS controllers handle inbound WS messages based on `action`
* Frame format is enforced for HTTP + WS (new simplified format)
* WebSocket rebroadcast can be enabled as a default behavior